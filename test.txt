class DavinciNer:
    TOKENS_PAR_MINUTE = 60000
    REQUESTS_PAR_MINUTE = 360
    SECONDS = 60

    def __init__(self, engine="davinci-003", tokenizer=None):
        self.engine = engine
        self.tokenizer = tokenizer

    def get_num_tokens(self, text): 
        return len(self.tokenizer(text)["input_ids"])

    def ner(self, df):
        results = []
        total_tokens = 0
        retry_after = 1  # temps de delai initié

        for i, row in df.iterrows():
            text = row['Phrase']

            prompt = f"When you are 100% sure, do an NER and retrieve the company or business (ORG), the person (PER), the location (LOC) and the miscellaneous (MISC) in the following python dictionary format, fill the list in double quotes and delete apostrophes, when you are not 100% sure, do not write anything : {{'ORG': [], 'LOC': [], 'PER': [], 'MISC': []}} on this text :\n {text}\n"

            num_tokens = self.get_num_tokens(prompt)
            total_tokens += num_tokens

            while True: 
                try:
                    # contraintes définies
                    if total_tokens > self.TOKENS_PAR_MINUTE or i >= self.REQUESTS_PAR_MINUTE:
                        sleep(self.SECONDS * 1.1)  # attente de plus d'une minute 
                        total_tokens = num_tokens  # reset des tokens

                    response = openai.Completion.create(
                        engine=self.engine,
                        prompt=prompt,
                        max_tokens=4000 - num_tokens,
                        temperature=0.7,
                        top_p=1.0,
                        frequency_penalty=0.0,
                        presence_penalty=0.0
                    )

                    ner_result = response.choices[0].text.strip()
                    # append des résultats, avec try si jamais
                    try:
                        result_dict = ast.literal_eval(ner_result)
                    except json.JSONDecodeError:
                        result_dict = {'ORG': [], 'LOC': [], 'PER': [], 'MISC': []} 

                    results.append(result_dict)
                    retry_after = 1  # reset du delai
                    break  # exit du while tant que c'est good
                except RateLimitError:
                    sleep(retry_after)  # sleep du temps de delai
                    retry_after *= 2  # double du temps de délai si on essai encore

        return results

